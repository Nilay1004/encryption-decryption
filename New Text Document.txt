def getUsers(departmentCode):
    headers = {
        'x-api-key' : api_config['INFRA_OPS_API_KEY']
    }
    user_info={
      "departmentCode": departmentCode,
      "resultType": "optional",
      "attributes": ["userId" ,"country"]
    }
    user_info_id=generateId('/knox/employee','POST',user_info,headers)
    #print(user_info_id)
    
    user_data=getDataFromID('/knox/employee/','GET',None,headers,user_info_id)
    #print(user_data)
    return user_data


Generate ut with unit test module
ChatGPT
Sure, I'll help you generate a unit test for the getUsers function using Python's unittest module. To mock external dependencies like generateId and getDataFromID, we'll use the unittest.mock library.

Here's the implementation of the unit test:

python
Copy code
import unittest
from unittest.mock import patch, MagicMock

# Assuming your module is named `user_module`
from user_module import getUsers

class TestGetUsers(unittest.TestCase):
    
    @patch('user_module.getDataFromID')
    @patch('user_module.generateId')
    def test_getUsers(self, mock_generateId, mock_getDataFromID):
        # Setup
        department_code = 'HR'
        expected_user_info_id = 'user_info_id_123'
        expected_user_data = {
            'users': [
                {'userId': 'user1', 'country': 'USA'},
                {'userId': 'user2', 'country': 'Canada'}
            ]
        }
        
        # Mocking
        mock_generateId.return_value = expected_user_info_id
        mock_getDataFromID.return_value = expected_user_data

        # Act
        result = getUsers(department_code)

        # Assertions
        self.assertEqual(result, expected_user_data)
        
        # Check if generateId was called with the correct arguments
        expected_user_info = {
            "departmentCode": department_code,
            "resultType": "optional",
            "attributes": ["userId", "country"]
        }
        headers = {'x-api-key': 'YOUR_API_KEY'}  # Replace with actual key if needed
        
        mock_generateId.assert_called_once_with('/knox/employee', 'POST', expected_user_info, headers)
        
        # Check if getDataFromID was called with the correct arguments
        mock_getDataFromID.assert_called_once_with('/knox/employee/', 'GET', None, headers, expected_user_info_id)

if __name__ == '__main__':
    unittest.main()
Explanation:
Imports:

unittest and unittest.mock for testing and mocking.
Import getUsers from your module (user_module is a placeholder; replace it with the actual module name).
Test Class and Method:

TestGetUsers is the test case class.
test_getUsers is the test method, which uses the patch decorator to mock generateId and getDataFromID.
Mock Setup:

Define department_code, expected_user_info_id, and expected_user_data as the inputs and expected outputs.
Set the return values of the mocked functions.
Assertions:

Assert that the result of getUsers matches the expected user data.
Use assert_called_once_with to check if the mocked functions were called with the correct arguments.
Note:
Replace 'YOUR_API_KEY' in the headers with the actual API key or dynamically get it from the api_config.
Adjust the module names (user_module, generateId, getDataFromID) to match your actual module structure.
This unit test ensures that your getUsers function correctly interacts with the generateId and getDataFromID functions and returns the expected data.

import json
import os
import logging
import time
import boto3
from concurrent.futures import ThreadPoolExecutor

from common import constants as constants
from common.utils import get_ssm_parameter , call_api , send_msg_to_sqs
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__))))
from user_sync_service import insert_dept_manager , insert_users , syncManagerSeqNo


logger = logging.getLogger()
# 10 -> debug, 20 -> info, 30 -> warning, 40 -> error, 50 -> critical
logger.setLevel(int(os.environ['LOG_LEVEL']))



While writing ut we it gives frozen os error
How to write condition that it sets by defaullt 20 for os.environ['LOG_LEVEL'] 
ChatGPT
To write a condition that sets the default log level to 20 (which corresponds to logging.INFO) if os.environ['LOG_LEVEL'] is not set, you can use the os.environ.get method with a default value. Here's how you can do it:

python
Copy code
import os
import logging

logger = logging.getLogger()
# Set the default log level to INFO (20) if LOG_LEVEL is not set in the environment variables
log_level = int(os.environ.get('LOG_LEVEL', 20))
logger.setLevel(log_level)
This way, if LOG_LEVEL is not set in the environment variables, it will default to 20 (INFO).

For the unit test, you need to mock the environment variable to simulate different scenarios. Hereâ€™s how you can write the unit test using the unittest module and unittest.mock to mock the environment variable:

python
Copy code
import unittest
from unittest.mock import patch
import logging
import your_module  # Replace with the actual module name where logger is defined

class TestLoggingLevel(unittest.TestCase):

    @patch.dict(os.environ, {'LOG_LEVEL': '10'})
    def test_log_level_debug(self):
        your_module.logger.setLevel(int(os.environ.get('LOG_LEVEL', 20)))
        self.assertEqual(your_module.logger.level, 10)

    @patch.dict(os.environ, {}, clear=True)
    def test_log_level_default(self):
        your_module.logger.setLevel(int(os.environ.get('LOG_LEVEL', 20)))
        self.assertEqual(your_module.logger.level, 20)

if __name__ == '__main__':
    unittest.main()
Explanation:
Imports:

unittest and unittest.mock.patch for testing and mocking.
Import your module where the logger is defined (your_module is a placeholder; replace it with the actual module name).
Test Class and Methods:

TestLoggingLevel is the test case class.
test_log_level_debug tests if the log level is set to DEBUG (10) when LOG_LEVEL is set to '10'.
test_log_level_default tests if the default log level is set to INFO (20) when LOG_LEVEL is not set.
Mocking Environment Variables:

Use @patch.dict to mock the os.environ dictionary.
In test_log_level_debug, os.environ is set to contain LOG_LEVEL with a value of '10'.
In test_log_level_default, os.environ is cleared to simulate the absence of LOG_LEVEL.
By running these tests, you can verify that your logger is correctly setting the log level based on the LOG_LEVEL environment variable, defaulting to INFO if it is not set.

import json
import os
import logging
import time
import boto3
from concurrent.futures import ThreadPoolExecutor

from common import constants as constants
from common.utils import get_ssm_parameter , call_api , send_msg_to_sqs
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__))))
from user_sync_service import insert_dept_manager , insert_users , syncManagerSeqNo


logger = logging.getLogger()
# 10 -> debug, 20 -> info, 30 -> warning, 40 -> error, 50 -> critical
logger.setLevel(int(os.environ['LOG_LEVEL'])) 
SQS_QUEUE_URL=os.environ['SQS_QUEUE_URL']
api_config=json.loads(get_ssm_parameter(constants.API_CONFIG))

current_department_code=""
current_uprSeqNo=""

def generateId(path,method,data,headers):
    attemps_count=0
    global current_department_code
    global current_uprSeqNo

    while(True):
        res_id=call_api(api_endpoint= api_config['INFRA_OPS_URL']+path , method=method , data=data,headers=headers)
        #print(res_id)
        if 'errorMessage' in res_id or 'error' in res_id:
            if attemps_count==2:
                print("Error : Couldn't generate ID to fetch data")
                #send back to sqs
                mssgBody={
                    'departmentCode' : current_department_code,
                    'uprSeqNo' : current_uprSeqNo
                }
                send_msg_to_sqs(SQS_QUEUE_URL,mssgBody)
                exit()
            else:
                attemps_count+=1
                print("Couldn't generate id for in try" +str(attemps_count))
                #print(data)
                time.sleep(1)
        else:
            break
    return res_id['id']


def getDataFromID(path,method,data,headers,id):
    global current_department_code
    global current_uprSeqNo
    
    retry_count=0
    required_data={}
    while(True):#polling data till success
        required_data = call_api(api_endpoint= api_config['INFRA_OPS_URL']+path+id , method=method , data=None ,headers=headers)
        if 'knox_data' in required_data and  required_data['knox_data']!='' and required_data['knox_data']['knox_status']=='completed':#we have a valid response
            break
        else :
            if retry_count==30:
                print("Error : Couldn't fetch data from polling")
                #send back to sqs
                mssgBody={
                    'departmentCode' : current_department_code,
                    'uprSeqNo' : current_uprSeqNo
                }
                send_msg_to_sqs(SQS_QUEUE_URL,mssgBody)
                exit()
            else:#retry
                retry_count+=1
                time.sleep(2)
    return required_data

def getDeptInfo(departmentCode):
    headers = {
        'x-api-key' : api_config['INFRA_OPS_API_KEY']
    }
    dept_info={
        "companyCode": "C10",
        "departmentCode": departmentCode
    }
    dept_info_id=generateId('/knox/organization','POST',dept_info,headers)
    #print(dept_info_id)
    
    dept_data=getDataFromID('/knox/organization/','GET',None,headers,dept_info_id)
    #print(dept_data)
    return dept_data

def getUsers(departmentCode):
    headers = {
        'x-api-key' : api_config['INFRA_OPS_API_KEY']
    }
    user_info={
      "departmentCode": departmentCode,
      "resultType": "optional",
      "attributes": ["userId" ,"country"]
    }
    user_info_id=generateId('/knox/employee','POST',user_info,headers)
    #print(user_info_id)
    
    user_data=getDataFromID('/knox/employee/','GET',None,headers,user_info_id)
    #print(user_data)
    return user_data

def getLowerDept(departmentCode):
    headers = {
        'x-api-key' : api_config['INFRA_OPS_API_KEY']
    }
    lower_dept_info={
        "companyCode": "C10",
        "uprDepartmentCode": departmentCode
    }
    lower_dept_info_id=generateId('/knox/organization','POST',lower_dept_info,headers)
    #print(lower_dept_info_id)
    
    lower_dept_data=getDataFromID('/knox/organization/','GET',None,headers,lower_dept_info_id)
    #print(lower_dept_data)
    return lower_dept_data

def lambda_handler(event, context):
    print(event)
    sqs=boto3.client('sqs')
    # TODO implement
    #api_config=json.loads(get_ssm_parameter(constants.API_CONFIG))
    print(api_config)
    global current_department_code
    global current_uprSeqNo
    
    departmentCode=""
    uprSeqNo=""
    if 'Records' in event:
        body=json.loads(event['Records'][0]['body'])
        print("Trigger via sqs")
        departmentCode=body['departmentCode']
        uprSeqNo=body['uprSeqNo']
    else:
        departmentCode=os.environ['head']
        uprSeqNo=os.environ['root_upr_seq']
        
    current_department_code=departmentCode
    current_uprSeqNo=uprSeqNo
    
    responses={}
    with ThreadPoolExecutor(max_workers=1) as executor:
        futures ={
            executor.submit(getDeptInfo,departmentCode):'dept_data',
            executor.submit(getUsers,departmentCode):'user_data',
            executor.submit(getLowerDept,departmentCode):'lower_dept'
        }
        
        for future in futures:
            name=futures[future]
            try:
                responses[name]=future.result()
            except Exception as e:
                print(f"Error processing for {name} : {e}")
                responses[name]=None
                
    #insert in dept_m
    print("Inseting in user_m")
    DeptManagerData=json.dumps([{
        'dept_id' : departmentCode,
        'mgr_id' : responses['dept_data']['knox_data']['organizations'][0]['managerId'],
        'regr_id' : int(os.environ['regr_id_batch']),
        'mdfr_id' : int(os.environ['mdfr_id_batch'])
    }])
    queryResult=insert_dept_manager(api_config,DeptManagerData)
    dept_seq_no=int(queryResult[0]['SEQ_NO'])
    managerId=responses['dept_data']['knox_data']['organizations'][0]['managerId']

    #insert in user_m
    print("Inseting in user_m")
    all_users=[]
    for user in responses['user_data']['knox_data']['employees']:
        if user['country'] is None:
            user['country']='NA'
        UserData={
            'user_id' : user['userId'],
            'cntr_cd' : user['country'],
            'dept_seq_no' : int(dept_seq_no),
            'regr_id' : int(os.environ['regr_id_batch']),
            'mdfr_id' : int(os.environ['mdfr_id_batch'])
        }
        if(user['userId']==managerId):
            if(uprSeqNo=='null'):
                del UserData['dept_seq_no']
            else:
                UserData['dept_seq_no']=int(uprSeqNo)
        all_users.append(UserData)

    all_users=json.dumps(all_users)
    #print(all_users)
    insert_users(api_config,all_users)

    #syncManagerSeqNo
    print("Sync Manager Seq No")
    mgr_id={
        'USER_ID' : managerId
    }
    mgr_id=json.dumps(mgr_id)
    syncManagerSeqNo(api_config,mgr_id)


    #sendLowerDepartmentsToSQS
    print("Lower Department")
    for org in responses['lower_dept']['knox_data']['organizations']:
        if org['departmentName'] is None or org['managerId'] is None:
            continue
        #print("Dept "+org['departmentName']+" ManagerId: "+org['managerId'] +" departmentCode: "+org['departmentCode'])
        #print("Call sqs for "+org['departmentCode'] +" with uprSeqNo: "+str(dept_seq_no))
        mssgBody={
            'departmentCode' : org['departmentCode'],
            'uprSeqNo' : dept_seq_no
        }
        send_msg_to_sqs(SQS_QUEUE_URL,mssgBody)

    print("Success for department "+departmentCode)
    return {
        'statusCode': 200,
        'body': json.dumps('Hello from Lambda!')
    }



Write unit test using unit test modeule
Handle cases like logger = logging.getLogger()
# 10 -> debug, 20 -> info, 30 -> warning, 40 -> error, 50 -> critical
logger.setLevel(int(os.environ['LOG_LEVEL'])) 
SQS_QUEUE_URL=os.environ['SQS_QUEUE_URL']
api_config=json.loads(get_ssm_parameter(constants.API_CONFIG)) with dummy value
ChatGPT
Here is a set of unit tests for your Lambda function using the unittest module. The tests include handling the logging configuration and environment variables.

python
Copy code
import unittest
from unittest.mock import patch, MagicMock
import logging
import json
import os
import boto3
from my_lambda_module import (
    getUsers, getDeptInfo, getLowerDept, lambda_handler, generateId, getDataFromID
)  # Replace 'my_lambda_module' with the actual module name

class TestMyLambdaFunction(unittest.TestCase):

    @patch.dict(os.environ, {'LOG_LEVEL': '10', 'SQS_QUEUE_URL': 'dummy_url', 'regr_id_batch': '1', 'mdfr_id_batch': '1'})
    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.boto3.client')
    def test_logging_and_env(self, mock_boto_client, mock_get_ssm_parameter):
        # Mocking SSM parameter and boto3 client
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_sqs = MagicMock()
        mock_boto_client.return_value = mock_sqs

        # Mocking API calls
        with patch('my_lambda_module.call_api') as mock_call_api:
            mock_call_api.return_value = {'id': 'dummy_id', 'knox_data': {'knox_status': 'completed', 'organizations': [{'managerId': 'dummy_manager'}]}}

            # Calling the lambda handler
            event = {
                'Records': [
                    {'body': json.dumps({'departmentCode': 'dummy_dept', 'uprSeqNo': 'dummy_seq'})}
                ]
            }
            context = {}

            result = lambda_handler(event, context)

            # Asserting the result
            self.assertEqual(result['statusCode'], 200)
            self.assertIn('Hello from Lambda!', result['body'])

            # Checking log level
            self.assertEqual(logging.getLogger().level, logging.DEBUG)

    @patch.dict(os.environ, {'LOG_LEVEL': '20', 'SQS_QUEUE_URL': 'dummy_url'})
    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_getUsers(self, mock_get_ssm_parameter, mock_call_api):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })
        
        mock_call_api.return_value = {
            'id': 'dummy_id',
            'knox_data': {
                'employees': [
                    {'userId': 'user1', 'country': 'USA'},
                    {'userId': 'user2', 'country': 'Canada'}
                ],
                'knox_status': 'completed'
            }
        }

        result = getUsers('dummy_dept')
        self.assertEqual(len(result['knox_data']['employees']), 2)
        self.assertEqual(result['knox_data']['employees'][0]['userId'], 'user1')

    @patch('my_lambda_module.send_msg_to_sqs')
    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_generateId(self, mock_get_ssm_parameter, mock_call_api, mock_send_msg_to_sqs):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })
        
        mock_call_api.side_effect = [{'errorMessage': 'error'}] * 2 + [{'id': 'dummy_id'}]

        result = generateId('/dummy/path', 'POST', {}, {})
        self.assertEqual(result, 'dummy_id')
        self.assertEqual(mock_call_api.call_count, 3)

if __name__ == '__main__':
    unittest.main()
Explanation:
Imports:

Import necessary modules and functions from your Lambda module.
Replace 'my_lambda_module' with the actual module name where your Lambda function resides.
Mocking Environment Variables:

Use @patch.dict to mock environment variables such as LOG_LEVEL, SQS_QUEUE_URL, regr_id_batch, and mdfr_id_batch.
Mocking External Dependencies:

Use @patch to mock external dependencies like get_ssm_parameter, call_api, and boto3.client.
Mock return values for these dependencies to simulate different scenarios.
Testing Logging and Environment Variables:

Check if the log level is set correctly based on the LOG_LEVEL environment variable.
Testing getUsers Function:

Mock the API response and assert that the function returns the correct data.
Testing generateId Function:

Mock the API response to simulate retries and successful ID generation.
Running the Tests:

Use unittest.main() to run the tests.
These tests cover the critical parts of your Lambda function, ensuring that it handles logging, environment variables, and external API calls correctly.

what about getDataFromID getDeptInfo etc
ChatGPT
Sure, I'll include the tests for getDataFromID, getDeptInfo, and getLowerDept as well. Below is the complete unit test script:

python
Copy code
import unittest
from unittest.mock import patch, MagicMock
import logging
import json
import os
import boto3
from my_lambda_module import (
    getUsers, getDeptInfo, getLowerDept, lambda_handler, generateId, getDataFromID
)  # Replace 'my_lambda_module' with the actual module name

class TestMyLambdaFunction(unittest.TestCase):

    @patch.dict(os.environ, {'LOG_LEVEL': '10', 'SQS_QUEUE_URL': 'dummy_url', 'regr_id_batch': '1', 'mdfr_id_batch': '1'})
    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.boto3.client')
    def test_logging_and_env(self, mock_boto_client, mock_get_ssm_parameter):
        # Mocking SSM parameter and boto3 client
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_sqs = MagicMock()
        mock_boto_client.return_value = mock_sqs

        # Mocking API calls
        with patch('my_lambda_module.call_api') as mock_call_api:
            mock_call_api.return_value = {'id': 'dummy_id', 'knox_data': {'knox_status': 'completed', 'organizations': [{'managerId': 'dummy_manager'}]}}

            # Calling the lambda handler
            event = {
                'Records': [
                    {'body': json.dumps({'departmentCode': 'dummy_dept', 'uprSeqNo': 'dummy_seq'})}
                ]
            }
            context = {}

            result = lambda_handler(event, context)

            # Asserting the result
            self.assertEqual(result['statusCode'], 200)
            self.assertIn('Hello from Lambda!', result['body'])

            # Checking log level
            self.assertEqual(logging.getLogger().level, logging.DEBUG)

    @patch.dict(os.environ, {'LOG_LEVEL': '20', 'SQS_QUEUE_URL': 'dummy_url'})
    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_getUsers(self, mock_get_ssm_parameter, mock_call_api):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })
        
        mock_call_api.return_value = {
            'id': 'dummy_id',
            'knox_data': {
                'employees': [
                    {'userId': 'user1', 'country': 'USA'},
                    {'userId': 'user2', 'country': 'Canada'}
                ],
                'knox_status': 'completed'
            }
        }

        result = getUsers('dummy_dept')
        self.assertEqual(len(result['knox_data']['employees']), 2)
        self.assertEqual(result['knox_data']['employees'][0]['userId'], 'user1')

    @patch('my_lambda_module.send_msg_to_sqs')
    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_generateId(self, mock_get_ssm_parameter, mock_call_api, mock_send_msg_to_sqs):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })
        
        mock_call_api.side_effect = [{'errorMessage': 'error'}] * 2 + [{'id': 'dummy_id'}]

        result = generateId('/dummy/path', 'POST', {}, {})
        self.assertEqual(result, 'dummy_id')
        self.assertEqual(mock_call_api.call_count, 3)

    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_getDataFromID(self, mock_get_ssm_parameter, mock_call_api):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_call_api.side_effect = [
            {'knox_data': {}, 'knox_status': 'pending'}, 
            {'knox_data': {'knox_status': 'completed'}}
        ]

        result = getDataFromID('/dummy/path', 'GET', None, {}, 'dummy_id')
        self.assertEqual(result['knox_data']['knox_status'], 'completed')
        self.assertEqual(mock_call_api.call_count, 2)

    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.generateId')
    @patch('my_lambda_module.getDataFromID')
    def test_getDeptInfo(self, mock_getDataFromID, mock_generateId, mock_get_ssm_parameter):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_generateId.return_value = 'dummy_id'
        mock_getDataFromID.return_value = {
            'knox_data': {'organizations': [{'managerId': 'dummy_manager'}]}
        }

        result = getDeptInfo('dummy_dept')
        self.assertEqual(result['knox_data']['organizations'][0]['managerId'], 'dummy_manager')
        mock_generateId.assert_called_once_with('/knox/organization', 'POST', {'companyCode': 'C10', 'departmentCode': 'dummy_dept'}, {'x-api-key': 'dummy_api_key'})
        mock_getDataFromID.assert_called_once_with('/knox/organization/', 'GET', None, {'x-api-key': 'dummy_api_key'}, 'dummy_id')

    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.generateId')
    @patch('my_lambda_module.getDataFromID')
    def test_getLowerDept(self, mock_getDataFromID, mock_generateId, mock_get_ssm_parameter):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_generateId.return_value = 'dummy_id'
        mock_getDataFromID.return_value = {
            'knox_data': {'organizations': [{'departmentCode': 'lower_dept'}]}
        }

        result = getLowerDept('dummy_dept')
        self.assertEqual(result['knox_data']['organizations'][0]['departmentCode'], 'lower_dept')
        mock_generateId.assert_called_once_with('/knox/organization', 'POST', {'companyCode': 'C10', 'uprDepartmentCode': 'dummy_dept'}, {'x-api-key': 'dummy_api_key'})
        mock_getDataFromID.assert_called_once_with('/knox/organization/', 'GET', None, {'x-api-key': 'dummy_api_key'}, 'dummy_id')

if __name__ == '__main__':
    unittest.main()
Explanation:
Test Setup:

Set up environment variables using @patch.dict.
Mock external dependencies such as get_ssm_parameter, call_api, generateId, and getDataFromID.
Test Methods:

test_logging_and_env: Checks if the log level is set correctly based on the environment variable.
test_getUsers: Mocks the API response for getUsers and asserts that it returns the correct data.
test_generateId: Mocks the API response to simulate retries and successful ID generation.
test_getDataFromID: Mocks the API response to simulate polling until the data is ready.
test_getDeptInfo: Mocks generateId and getDataFromID to test the getDeptInfo function.
test_getLowerDept: Mocks generateId and getDataFromID to test the getLowerDept function.
Mocking and Assertions:

Use mock_call_api.side_effect to simulate different responses for retries.
Use mock_generateId.assert_called_once_with and mock_getDataFromID.assert_called_once_with to verify that the functions are called with the correct arguments.
Running the Tests:

Use unittest.main() to run the tests.
These tests cover the main functions in your Lambda function, ensuring that they handle logging, environment variables, and external API calls correctly.

what about insert_dept_manager  insert_users syncManagerSeqNo
ChatGPT
To include tests for insert_dept_manager, insert_users, and syncManagerSeqNo, we need to ensure these functions are mocked and their calls are verified in the unit tests.

Below is the updated unit test script that includes these functions:

python
Copy code
import unittest
from unittest.mock import patch, MagicMock
import logging
import json
import os
import boto3
from my_lambda_module import (
    getUsers, getDeptInfo, getLowerDept, lambda_handler, generateId, getDataFromID, insert_dept_manager, insert_users, syncManagerSeqNo
)  # Replace 'my_lambda_module' with the actual module name

class TestMyLambdaFunction(unittest.TestCase):

    @patch.dict(os.environ, {'LOG_LEVEL': '10', 'SQS_QUEUE_URL': 'dummy_url', 'regr_id_batch': '1', 'mdfr_id_batch': '1'})
    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.boto3.client')
    def test_logging_and_env(self, mock_boto_client, mock_get_ssm_parameter):
        # Mocking SSM parameter and boto3 client
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_sqs = MagicMock()
        mock_boto_client.return_value = mock_sqs

        # Mocking API calls
        with patch('my_lambda_module.call_api') as mock_call_api:
            mock_call_api.return_value = {'id': 'dummy_id', 'knox_data': {'knox_status': 'completed', 'organizations': [{'managerId': 'dummy_manager'}]}}

            # Calling the lambda handler
            event = {
                'Records': [
                    {'body': json.dumps({'departmentCode': 'dummy_dept', 'uprSeqNo': 'dummy_seq'})}
                ]
            }
            context = {}

            result = lambda_handler(event, context)

            # Asserting the result
            self.assertEqual(result['statusCode'], 200)
            self.assertIn('Hello from Lambda!', result['body'])

            # Checking log level
            self.assertEqual(logging.getLogger().level, logging.DEBUG)

    @patch.dict(os.environ, {'LOG_LEVEL': '20', 'SQS_QUEUE_URL': 'dummy_url'})
    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_getUsers(self, mock_get_ssm_parameter, mock_call_api):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })
        
        mock_call_api.return_value = {
            'id': 'dummy_id',
            'knox_data': {
                'employees': [
                    {'userId': 'user1', 'country': 'USA'},
                    {'userId': 'user2', 'country': 'Canada'}
                ],
                'knox_status': 'completed'
            }
        }

        result = getUsers('dummy_dept')
        self.assertEqual(len(result['knox_data']['employees']), 2)
        self.assertEqual(result['knox_data']['employees'][0]['userId'], 'user1')

    @patch('my_lambda_module.send_msg_to_sqs')
    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_generateId(self, mock_get_ssm_parameter, mock_call_api, mock_send_msg_to_sqs):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })
        
        mock_call_api.side_effect = [{'errorMessage': 'error'}] * 2 + [{'id': 'dummy_id'}]

        result = generateId('/dummy/path', 'POST', {}, {})
        self.assertEqual(result, 'dummy_id')
        self.assertEqual(mock_call_api.call_count, 3)

    @patch('my_lambda_module.call_api')
    @patch('my_lambda_module.get_ssm_parameter')
    def test_getDataFromID(self, mock_get_ssm_parameter, mock_call_api):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_call_api.side_effect = [
            {'knox_data': {}, 'knox_status': 'pending'}, 
            {'knox_data': {'knox_status': 'completed'}}
        ]

        result = getDataFromID('/dummy/path', 'GET', None, {}, 'dummy_id')
        self.assertEqual(result['knox_data']['knox_status'], 'completed')
        self.assertEqual(mock_call_api.call_count, 2)

    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.generateId')
    @patch('my_lambda_module.getDataFromID')
    def test_getDeptInfo(self, mock_getDataFromID, mock_generateId, mock_get_ssm_parameter):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_generateId.return_value = 'dummy_id'
        mock_getDataFromID.return_value = {
            'knox_data': {'organizations': [{'managerId': 'dummy_manager'}]}
        }

        result = getDeptInfo('dummy_dept')
        self.assertEqual(result['knox_data']['organizations'][0]['managerId'], 'dummy_manager')
        mock_generateId.assert_called_once_with('/knox/organization', 'POST', {'companyCode': 'C10', 'departmentCode': 'dummy_dept'}, {'x-api-key': 'dummy_api_key'})
        mock_getDataFromID.assert_called_once_with('/knox/organization/', 'GET', None, {'x-api-key': 'dummy_api_key'}, 'dummy_id')

    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.generateId')
    @patch('my_lambda_module.getDataFromID')
    def test_getLowerDept(self, mock_getDataFromID, mock_generateId, mock_get_ssm_parameter):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        mock_generateId.return_value = 'dummy_id'
        mock_getDataFromID.return_value = {
            'knox_data': {'organizations': [{'departmentCode': 'lower_dept'}]}
        }

        result = getLowerDept('dummy_dept')
        self.assertEqual(result['knox_data']['organizations'][0]['departmentCode'], 'lower_dept')
        mock_generateId.assert_called_once_with('/knox/organization', 'POST', {'companyCode': 'C10', 'uprDepartmentCode': 'dummy_dept'}, {'x-api-key': 'dummy_api_key'})
        mock_getDataFromID.assert_called_once_with('/knox/organization/', 'GET', None, {'x-api-key': 'dummy_api_key'}, 'dummy_id')

    @patch('my_lambda_module.get_ssm_parameter')
    @patch('my_lambda_module.insert_dept_manager')
    @patch('my_lambda_module.insert_users')
    @patch('my_lambda_module.syncManagerSeqNo')
    def test_lambda_handler_inserts(self, mock_syncManagerSeqNo, mock_insert_users, mock_insert_dept_manager, mock_get_ssm_parameter):
        mock_get_ssm_parameter.return_value = json.dumps({
            'INFRA_OPS_API_KEY': 'dummy_api_key',
            'INFRA_OPS_URL': 'https://dummyurl.com'
        })

        event = {
            'Records': [
                {'body': json.dumps({'departmentCode': 'dummy_dept', 'uprSeqNo': 'dummy_seq'})}
            ]
        }
        context = {}

        with patch('my_lambda_module.call_api') as mock_call_api:
            mock_call_api.side_effect = [
                {'id': 'dummy_id'},  # For generateId
                {'knox_data': {'knox_status': 'completed', 'organizations': [{'managerId': 'dummy_manager', 'departmentCode': 'dummy_dept'}]}},  # For getDataFromID
                {'knox_data': {'employees': [{'userId': 'user1', 'country': 'USA'}, {'userId': 'user2', 'country': 'Canada'}]}},  # For getUsers
                {'knox_data': {'organizations': [{'departmentCode': 'lower_dept', 'departmentName': 'Lower Dept', 'managerId': 'lower_manager'}]}}  # For getLowerDept
            ]

            lambda_handler(event, context)

            mock_insert_dept_manager.assert_called_once()
            mock_insert_users.assert_called_once()
            mock_syncManagerSeqNo.assert_called_once()

if __name__ == '__main__':
    unittest.main()
Explanation:
Test Setup:

Set up environment variables using @patch.dict.
Mock external dependencies such as get_ssm_parameter, call_api, generateId, getDataFromID, insert_dept_manager, insert_users, and syncManagerSeqNo.
Test Methods:

test_logging_and_env: Checks if the log level is set correctly based on the environment variable.
test_getUsers: Mocks the API response for getUsers and asserts that it returns the correct data.
test_generateId: Mocks the API response to simulate retries and successful ID generation.
test_getDataFromID: Mocks the API response to simulate polling until the data is ready.
test_getDeptInfo: Mocks generateId and getDataFromID to test the getDeptInfo function.
test_getLowerDept: Mocks generateId and getDataFromID to test the getLowerDept function.
test_lambda_handler_inserts: Mocks the main functions and API calls within the lambda_handler and asserts that insert_dept_manager, insert_users, and syncManagerSeqNo are called.
Mocking and Assertions:

Use mock_call_api.side_effect to simulate different responses for retries and successful data retrieval.
Use mock_generateId.assert_called_once_with and mock_getDataFromID.assert_called_once_with to verify that the functions are called with the correct arguments.
Assert that insert_dept_manager, insert_users, and syncManagerSeqNo are called within the lambda_handler.
Running the Tests:

Use unittest.main() to run the tests.
These tests ensure that your Lambda function handles logging, environment variables, external API calls, and the main insertion functions correctly.









